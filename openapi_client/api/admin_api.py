# coding: utf-8

"""
    NamSor API v2

    NamSor API v2 : enpoints to process personal names (gender, cultural origin or ethnicity) in all alphabets or languages. By default, enpoints use 1 unit per name (ex. Gender), but Ethnicity classification uses 10 to 20 units per name depending on taxonomy. Use GET methods for small tests, but prefer POST methods for higher throughput (batch processing of up to 100 names at a time). Need something you can't find here? We have many more features coming soon. Let us know, we'll do our best to add it!   # noqa: E501

    OpenAPI spec version: 2.0.18
    Contact: contact@namsor.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openapi_client.api_client import ApiClient


class AdminApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def anonymize(self, source, anonymized, token, **kwargs):  # noqa: E501
        """Activate/deactivate anonymization for a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.anonymize(source, anonymized, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: (required)
        :param bool anonymized: (required)
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.anonymize_with_http_info(source, anonymized, token, **kwargs)  # noqa: E501
        else:
            (data) = self.anonymize_with_http_info(source, anonymized, token, **kwargs)  # noqa: E501
            return data

    def anonymize_with_http_info(self, source, anonymized, token, **kwargs):  # noqa: E501
        """Activate/deactivate anonymization for a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.anonymize_with_http_info(source, anonymized, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: (required)
        :param bool anonymized: (required)
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['source', 'anonymized', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method anonymize" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'source' is set
        if ('source' not in local_var_params or
                local_var_params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `anonymize`")  # noqa: E501
        # verify the required parameter 'anonymized' is set
        if ('anonymized' not in local_var_params or
                local_var_params['anonymized'] is None):
            raise ValueError("Missing the required parameter `anonymized` when calling `anonymize`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `anonymize`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'source' in local_var_params:
            path_params['source'] = local_var_params['source']  # noqa: E501
        if 'anonymized' in local_var_params:
            path_params['anonymized'] = local_var_params['anonymized']  # noqa: E501
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/anonymize/{source}/{anonymized}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIKeyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def anonymize1(self, source, anonymized, **kwargs):  # noqa: E501
        """Activate/deactivate anonymization for a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.anonymize1(source, anonymized, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: (required)
        :param bool anonymized: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.anonymize1_with_http_info(source, anonymized, **kwargs)  # noqa: E501
        else:
            (data) = self.anonymize1_with_http_info(source, anonymized, **kwargs)  # noqa: E501
            return data

    def anonymize1_with_http_info(self, source, anonymized, **kwargs):  # noqa: E501
        """Activate/deactivate anonymization for a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.anonymize1_with_http_info(source, anonymized, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: (required)
        :param bool anonymized: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['source', 'anonymized']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method anonymize1" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'source' is set
        if ('source' not in local_var_params or
                local_var_params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `anonymize1`")  # noqa: E501
        # verify the required parameter 'anonymized' is set
        if ('anonymized' not in local_var_params or
                local_var_params['anonymized'] is None):
            raise ValueError("Missing the required parameter `anonymized` when calling `anonymize1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'source' in local_var_params:
            path_params['source'] = local_var_params['source']  # noqa: E501
        if 'anonymized' in local_var_params:
            path_params['anonymized'] = local_var_params['anonymized']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/anonymize/{source}/{anonymized}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_key_info(self, **kwargs):  # noqa: E501
        """Read API Key info.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_key_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_key_info_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.api_key_info_with_http_info(**kwargs)  # noqa: E501
            return data

    def api_key_info_with_http_info(self, **kwargs):  # noqa: E501
        """Read API Key info.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_key_info_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_key_info" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/apiKeyInfo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIKeyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_status(self, **kwargs):  # noqa: E501
        """Prints the current status of the classifiers. A classifier name in apiStatus corresponds to a service name in apiServices.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_status(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIClassifiersStatusOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_status_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.api_status_with_http_info(**kwargs)  # noqa: E501
            return data

    def api_status_with_http_info(self, **kwargs):  # noqa: E501
        """Prints the current status of the classifiers. A classifier name in apiStatus corresponds to a service name in apiServices.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_status_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIClassifiersStatusOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_status" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/apiStatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIClassifiersStatusOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_usage(self, **kwargs):  # noqa: E501
        """Print current API usage.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_usage_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.api_usage_with_http_info(**kwargs)  # noqa: E501
            return data

    def api_usage_with_http_info(self, **kwargs):  # noqa: E501
        """Print current API usage.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIPeriodUsageOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_usage" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/apiUsage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIPeriodUsageOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_usage_history(self, **kwargs):  # noqa: E501
        """Print historical API usage.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage_history(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIUsageHistoryOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_usage_history_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.api_usage_history_with_http_info(**kwargs)  # noqa: E501
            return data

    def api_usage_history_with_http_info(self, **kwargs):  # noqa: E501
        """Print historical API usage.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage_history_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIUsageHistoryOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_usage_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/apiUsageHistory', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIUsageHistoryOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_usage_history_aggregate(self, **kwargs):  # noqa: E501
        """Print historical API usage (in an aggregated view, by service, by day/hour/min).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage_history_aggregate(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIUsageAggregatedOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_usage_history_aggregate_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.api_usage_history_aggregate_with_http_info(**kwargs)  # noqa: E501
            return data

    def api_usage_history_aggregate_with_http_info(self, **kwargs):  # noqa: E501
        """Print historical API usage (in an aggregated view, by service, by day/hour/min).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_usage_history_aggregate_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIUsageAggregatedOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_usage_history_aggregate" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/apiUsageHistoryAggregate', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIUsageAggregatedOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def available_services(self, **kwargs):  # noqa: E501
        """List of classification services and usage cost in Units per classification (default is 1=ONE Unit). Some API endpoints (ex. Corridor) combine multiple classifiers.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.available_services(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIServicesOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.available_services_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.available_services_with_http_info(**kwargs)  # noqa: E501
            return data

    def available_services_with_http_info(self, **kwargs):  # noqa: E501
        """List of classification services and usage cost in Units per classification (default is 1=ONE Unit). Some API endpoints (ex. Corridor) combine multiple classifiers.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.available_services_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: APIServicesOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method available_services" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/apiServices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIServicesOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def disable(self, source, disabled, **kwargs):  # noqa: E501
        """Activate/deactivate an API Key.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable(source, disabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: The API Key to set as enabled/disabled. (required)
        :param bool disabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.disable_with_http_info(source, disabled, **kwargs)  # noqa: E501
        else:
            (data) = self.disable_with_http_info(source, disabled, **kwargs)  # noqa: E501
            return data

    def disable_with_http_info(self, source, disabled, **kwargs):  # noqa: E501
        """Activate/deactivate an API Key.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.disable_with_http_info(source, disabled, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: The API Key to set as enabled/disabled. (required)
        :param bool disabled: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['source', 'disabled']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method disable" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'source' is set
        if ('source' not in local_var_params or
                local_var_params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `disable`")  # noqa: E501
        # verify the required parameter 'disabled' is set
        if ('disabled' not in local_var_params or
                local_var_params['disabled'] is None):
            raise ValueError("Missing the required parameter `disabled` when calling `disable`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'source' in local_var_params:
            path_params['source'] = local_var_params['source']  # noqa: E501
        if 'disabled' in local_var_params:
            path_params['disabled'] = local_var_params['disabled']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/disable/{source}/{disabled}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def learnable(self, source, learnable, **kwargs):  # noqa: E501
        """Activate/deactivate learning from a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.learnable(source, learnable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: The API Key to set as learnable/non learnable. (required)
        :param bool learnable: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.learnable_with_http_info(source, learnable, **kwargs)  # noqa: E501
        else:
            (data) = self.learnable_with_http_info(source, learnable, **kwargs)  # noqa: E501
            return data

    def learnable_with_http_info(self, source, learnable, **kwargs):  # noqa: E501
        """Activate/deactivate learning from a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.learnable_with_http_info(source, learnable, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: The API Key to set as learnable/non learnable. (required)
        :param bool learnable: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['source', 'learnable']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method learnable" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'source' is set
        if ('source' not in local_var_params or
                local_var_params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `learnable`")  # noqa: E501
        # verify the required parameter 'learnable' is set
        if ('learnable' not in local_var_params or
                local_var_params['learnable'] is None):
            raise ValueError("Missing the required parameter `learnable` when calling `learnable`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'source' in local_var_params:
            path_params['source'] = local_var_params['source']  # noqa: E501
        if 'learnable' in local_var_params:
            path_params['learnable'] = local_var_params['learnable']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/learnable/{source}/{learnable}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def learnable1(self, source, learnable, token, **kwargs):  # noqa: E501
        """Activate/deactivate learning from a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.learnable1(source, learnable, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: The API Key to set as learnable/non learnable. (required)
        :param bool learnable: (required)
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.learnable1_with_http_info(source, learnable, token, **kwargs)  # noqa: E501
        else:
            (data) = self.learnable1_with_http_info(source, learnable, token, **kwargs)  # noqa: E501
            return data

    def learnable1_with_http_info(self, source, learnable, token, **kwargs):  # noqa: E501
        """Activate/deactivate learning from a source.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.learnable1_with_http_info(source, learnable, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str source: The API Key to set as learnable/non learnable. (required)
        :param bool learnable: (required)
        :param str token: (required)
        :return: APIKeyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['source', 'learnable', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method learnable1" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'source' is set
        if ('source' not in local_var_params or
                local_var_params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `learnable1`")  # noqa: E501
        # verify the required parameter 'learnable' is set
        if ('learnable' not in local_var_params or
                local_var_params['learnable'] is None):
            raise ValueError("Missing the required parameter `learnable` when calling `learnable1`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in local_var_params or
                local_var_params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `learnable1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'source' in local_var_params:
            path_params['source'] = local_var_params['source']  # noqa: E501
        if 'learnable' in local_var_params:
            path_params['learnable'] = local_var_params['learnable']  # noqa: E501
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/learnable/{source}/{learnable}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIKeyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def software_version(self, **kwargs):  # noqa: E501
        """Get the current software version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.software_version(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SoftwareVersionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.software_version_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.software_version_with_http_info(**kwargs)  # noqa: E501
            return data

    def software_version_with_http_info(self, **kwargs):  # noqa: E501
        """Get the current software version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.software_version_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SoftwareVersionOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method software_version" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/softwareVersion', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SoftwareVersionOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def taxonomy_classes(self, classifier_name, **kwargs):  # noqa: E501
        """Print the taxonomy classes valid for the given classifier.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.taxonomy_classes(classifier_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str classifier_name: (required)
        :return: APIClassifierTaxonomyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.taxonomy_classes_with_http_info(classifier_name, **kwargs)  # noqa: E501
        else:
            (data) = self.taxonomy_classes_with_http_info(classifier_name, **kwargs)  # noqa: E501
            return data

    def taxonomy_classes_with_http_info(self, classifier_name, **kwargs):  # noqa: E501
        """Print the taxonomy classes valid for the given classifier.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.taxonomy_classes_with_http_info(classifier_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str classifier_name: (required)
        :return: APIClassifierTaxonomyOut
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['classifier_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method taxonomy_classes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'classifier_name' is set
        if ('classifier_name' not in local_var_params or
                local_var_params['classifier_name'] is None):
            raise ValueError("Missing the required parameter `classifier_name` when calling `taxonomy_classes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'classifier_name' in local_var_params:
            path_params['classifierName'] = local_var_params['classifier_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['api_key']  # noqa: E501

        return self.api_client.call_api(
            '/api2/json/taxonomyClasses/{classifierName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIClassifierTaxonomyOut',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
